import { PrismaClient, OrderStatus as PrismaOrderStatus, PaymentMethod as PrismaPaymentMethod } from '@prisma/client';
import { IOrderRepository } from '../../application/ports/outbound';
import { Order, OrderItem, OrderItemProps } from '../../domain/entities';
import { OrderStatusEnum } from '../../domain/value-objects';
import { BaseRepository } from './BaseRepository';

/**
 * Implementación Prisma del repositorio de órdenes
 */
export class PrismaOrderRepository extends BaseRepository implements IOrderRepository {
  constructor(prisma: PrismaClient) {
    super(prisma);
  }

  async save(order: Order): Promise<Order> {
    const client = this.getClient();

    // Crear la orden con sus items en una sola operación
    const created = await client.order.create({
      data: {
        id: order.id,
        tenantId: order.tenantId,
        orderNumber: order.orderNumber,
        customerName: order.customerName,
        customerPhone: order.customerPhone,
        customerEmail: order.customerEmail,
        status: order.status.value as PrismaOrderStatus,
        paymentMethod: order.paymentMethod as PrismaPaymentMethod,
        subtotalInCents: order.subtotalInCents,
        totalInCents: order.totalInCents,
        customerNotes: order.customerNotes,
        internalNotes: order.internalNotes,
        createdAt: order.createdAt,
        updatedAt: order.updatedAt,
        paidAt: order.paidAt,
        completedAt: order.completedAt,
        cancelledAt: order.cancelledAt,
        items: {
          create: order.items.map((item) => ({
            id: item.id,
            productId: item.productId,
            productName: item.productName,
            productIsService: item.productIsService,
            unitPriceInCents: item.unitPriceInCents,
            quantity: item.quantity,
            subtotalInCents: item.subtotalInCents,
            appointmentDate: item.appointmentDate,
            appointmentTime: item.appointmentTime,
            durationMinutes: item.durationMinutes,
          })),
        },
      },
      include: {
        items: true,
      },
    });

    return this.toDomainEntity(created);
  }

  async findById(id: string): Promise<Order | null> {
    const client = this.getClient();

    const order = await client.order.findUnique({
      where: { id },
      include: { items: true },
    });

    if (!order) return null;

    return this.toDomainEntity(order);
  }

  async findByTenantAndNumber(
    tenantId: string,
    orderNumber: number,
  ): Promise<Order | null> {
    const client = this.getClient();

    const order = await client.order.findUnique({
      where: {
        tenantId_orderNumber: {
          tenantId,
          orderNumber,
        },
      },
      include: { items: true },
    });

    if (!order) return null;

    return this.toDomainEntity(order);
  }

  async findByTenant(
    tenantId: string,
    options?: {
      status?: OrderStatusEnum;
      limit?: number;
      offset?: number;
    },
  ): Promise<Order[]> {
    const client = this.getClient();

    const orders = await client.order.findMany({
      where: {
        tenantId,
        ...(options?.status && { status: options.status as PrismaOrderStatus }),
      },
      include: { items: true },
      orderBy: { createdAt: 'desc' },
      take: options?.limit,
      skip: options?.offset,
    });

    return orders.map(this.toDomainEntity);
  }

  async update(order: Order): Promise<Order> {
    const client = this.getClient();

    const updated = await client.order.update({
      where: { id: order.id },
      data: {
        status: order.status.value as PrismaOrderStatus,
        internalNotes: order.internalNotes,
        updatedAt: order.updatedAt,
        paidAt: order.paidAt,
        completedAt: order.completedAt,
        cancelledAt: order.cancelledAt,
      },
      include: { items: true },
    });

    return this.toDomainEntity(updated);
  }

  async getNextOrderNumber(tenantId: string): Promise<number> {
    const client = this.getClient();

    // Usar upsert para crear o actualizar el contador
    const counter = await client.tenantOrderCounter.upsert({
      where: { tenantId },
      update: {
        lastNumber: {
          increment: 1,
        },
      },
      create: {
        tenantId,
        lastNumber: 1,
      },
    });

    return counter.lastNumber;
  }

  private toDomainEntity(
    prismaOrder: {
      id: string;
      tenantId: string;
      orderNumber: number;
      customerName: string;
      customerPhone: string;
      customerEmail: string | null;
      status: PrismaOrderStatus;
      paymentMethod: PrismaPaymentMethod;
      subtotalInCents: number;
      totalInCents: number;
      customerNotes: string | null;
      internalNotes: string | null;
      createdAt: Date;
      updatedAt: Date;
      paidAt: Date | null;
      completedAt: Date | null;
      cancelledAt: Date | null;
      items: Array<{
        id: string;
        orderId: string;
        productId: string;
        productName: string;
        productIsService: boolean;
        unitPriceInCents: number;
        quantity: number;
        subtotalInCents: number;
        appointmentDate: Date | null;
        appointmentTime: string | null;
        durationMinutes: number | null;
        createdAt: Date;
      }>;
    },
  ): Order {
    const items = prismaOrder.items.map((item) => {
      const props: OrderItemProps = {
        id: item.id,
        orderId: item.orderId,
        productId: item.productId,
        productName: item.productName,
        productIsService: item.productIsService,
        unitPriceInCents: item.unitPriceInCents,
        quantity: item.quantity,
        appointmentDate: item.appointmentDate,
        appointmentTime: item.appointmentTime,
        durationMinutes: item.durationMinutes,
      };
      return new OrderItem(props);
    });

    return new Order({
      id: prismaOrder.id,
      tenantId: prismaOrder.tenantId,
      orderNumber: prismaOrder.orderNumber,
      customerName: prismaOrder.customerName,
      customerPhone: prismaOrder.customerPhone,
      customerEmail: prismaOrder.customerEmail,
      status: prismaOrder.status as OrderStatusEnum,
      paymentMethod: prismaOrder.paymentMethod as 'SINPE' | 'CASH',
      customerNotes: prismaOrder.customerNotes,
      internalNotes: prismaOrder.internalNotes,
      createdAt: prismaOrder.createdAt,
      updatedAt: prismaOrder.updatedAt,
      paidAt: prismaOrder.paidAt,
      completedAt: prismaOrder.completedAt,
      cancelledAt: prismaOrder.cancelledAt,
      items,
    });
  }
}
